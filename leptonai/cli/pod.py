"""
Pod is a module that provides a way to create and manage DGX Cloud Lepton Pods.

A Pod (short for "DGX Cloud Lepton Pod") is a container runtime that allows you to
run interactive sessions on the DGX Cloud Lepton cloud. Think of it as a remote
server that you can access via SSH, and use it as a remote development
environment. You can use it to run Jupyter notebooks, or to run a terminal
session, similar to a cloud VM but much more lightweight.
"""

import subprocess
import sys
import json
import re

import click
from loguru import logger
from rich.console import Console
from rich.table import Table

from leptonai.config import (
    VALID_SHAPES,
    DEFAULT_RESOURCE_SHAPE,
    SSH_PORT,
    TCP_PORT,
    TCP_JUPYTER_PORT,
)
from leptonai.api.v1 import types
from .util import (
    click_group,
    _get_only_replica_public_ip,
    _validate_queue_priority,
    apply_nodegroup_and_queue_config,
    make_name_id_cell,
    colorize_state,
    format_timestamp_ms,
)
from .util import make_container_ports_from_str_list
from ..api.v2.client import APIClient
from ..api.v1.photon import make_mounts_from_strings, make_env_vars_from_strings
from ..api.v1.types.deployment import (
    LeptonDeploymentState,
    ResourceRequirement,
    LeptonLog,
    LeptonContainer,
)
from ..api.v1.types.common import LeptonUserSecurityContext


console = Console(highlight=False)


@click_group()
def pod():
    """
    Manages pods on the DGX Cloud Lepton.

    A Pod (short for "DGX Cloud Lepton Pod") is a container runtime that allows you to
    run interactive sessions on the DGX Cloud Lepton. Think of it as a remote
    server that you can access via SSH, and use it as a remote development
    environment. You can use it to run Jupyter notebooks, or to run a terminal
    session, similar to a cloud VM but much more lightweight.
    """
    pass


@pod.command()
@click.option(
    "--name", "-n", type=str, help="Name of the pod to create.", required=True
)
@click.option(
    "--template",
    "-t",
    help="Template ID to render the pod specification from.",
    type=str,
)
@click.option(
    "--run",
    help='Command string ("run") to substitute into the template.',
    type=str,
)
@click.option(
    "--file",
    "-f",
    type=click.Path(
        exists=False,
        file_okay=True,
        dir_okay=False,
        readable=True,
        resolve_path=True,
    ),
    help=(
        "If provided, load the pod spec from this JSON file before applying CLI"
        " overrides. The file could be generated by UI → CLI → 'Use spec file', or by"
        " running:  pod get -i <pod_id> --path <download_path>`."
    ),
    required=False,
)
@click.option(
    "--resource-shape",
    "-rs",
    type=str,
    help="Resource shape for the pod. Available types are: '"
    + "', '".join(VALID_SHAPES)
    + "'.",
    default=None,
)
@click.option(
    "--mount",
    help=(
        "Persistent storage to be mounted to the deployment, in the format"
        " `STORAGE_PATH:MOUNT_PATH`."
    ),
    multiple=True,
)
@click.option(
    "--env",
    "-e",
    help="Environment variables to pass to the deployment, in the format `NAME=VALUE`.",
    multiple=True,
)
@click.option(
    "--secret",
    "-s",
    help=(
        "Secrets to pass to the deployment, in the format `NAME=SECRET_NAME`. If"
        " secret name is also the environment variable name, you can"
        " omit it and simply pass `SECRET_NAME`."
    ),
    multiple=True,
)
@click.option(
    "--image-pull-secrets",
    type=str,
    help="Secrets to use for pulling images.",
    multiple=True,
)
@click.option(
    "--node-group",
    "-ng",
    "node_groups",
    help=(
        "Node group for the pod. If not set, use on-demand resources. You can repeat"
        " this flag multiple times to choose multiple node groups. Multiple node group"
        " option is currently not supported but coming soon for enterprise users. Only"
        " the first node group will be set if you input multiple node groups at this"
        " time."
    ),
    type=str,
    multiple=True,
)
@click.option("--container-image", type=str, help="Container image to run.")
@click.option(
    "--container-command",
    type=str,
    help="Command to run in the container.",
)
@click.option(
    "--log-collection",
    "-lg",
    type=bool,
    help=(
        "Enable or disable log collection (true/false). If not provided, the workspace"
        " setting will be used."
    ),
)
@click.option(
    "--node-id",
    "-ni",
    "node_ids",
    help=(
        "Node for the pod. You can repeat this flag multiple times to choose multiple"
        " nodes. Please specify the node group when you are using this option"
    ),
    type=str,
    multiple=True,
)
@click.option(
    "--queue-priority",
    "-qp",
    "queue_priority",
    callback=_validate_queue_priority,
    default=None,
    help="Set the priority for this pod (dedicated node groups only).",
)
@click.option(
    "--can-be-preempted",
    "-cbp",
    is_flag=True,
    default=None,
    help="Allow this pod to be preempted by higher priority workloads.",
)
@click.option(
    "--can-preempt",
    "-cp",
    is_flag=True,
    default=None,
    help="Allow this pod to preempt lower priority workloads.",
)
@click.option(
    "--container-port",
    type=str,
    help=(
        "Container ports to expose. Format: <port>:<protocol>:<strategy>[:strategy].\n "
        " <port>     : 1-65535\n  <protocol> : tcp | udp | sctp\n  <strategy> : proxy |"
        " hostmap\n              - hostmap: host port (random 40000-65535) mapped on"
        " node IP\n              - proxy  : generate public URL; only ONE port"
        " can enable proxy\n\nExamples:\n  8080:tcp:proxy                -> proxy"
        " only\n  8080:udp:hostmap             -> host mapping only\n "
        " 8080:tcp:proxy:hostmap       -> both strategies (note: only first proxy will"
        " take effect)\n\nNotice: Exposing container ports may increase your service's"
        " security risk. Please implement appropriate authentication and security"
        " controls; you are solely responsible for the security of any services"
        " exposed."
    ),
    multiple=True,
)
@click.option(
    "--with-reservation",
    type=str,
    help=(
        "Assign the pod to a specific reserved compute resource using a reservation ID "
        "(only applicable to dedicated node groups)."
    ),
)
@click.option(
    "--allow-burst-to-other-reservation",
    is_flag=True,
    default=False,
    help=(
        "If set, the pod can temporarily use free resources from nodes reserved by "
        "other reservations. Be aware that when a new workload bound to those "
        "reservations starts, your pod may be evicted."
    ),
)
@click.option(
    "--privileged",
    is_flag=True,
    default=None,
    help="Run the pod in privileged mode.",
)
def create(
    name,
    template,
    run,
    file,
    resource_shape,
    mount,
    env,
    secret,
    image_pull_secrets,
    node_groups,
    container_image,
    container_command,
    container_port,
    log_collection,
    node_ids,
    queue_priority,
    can_be_preempted,
    can_preempt,
    privileged,
    with_reservation,
    allow_burst_to_other_reservation,
):
    """
    Creates a pod with the given resource shape, mount, env and secret.
    """

    client = APIClient()

    # Validate template/file mutual exclusivity
    if run is not None and template is None:
        console.print("[red]Error[/]: --run can only be used together with --template.")
        sys.exit(1)

    if template and file:
        console.print("[red]Error[/]: --template and --file cannot be used together.")
        sys.exit(1)

    spec_from_file = None
    if template:
        try:
            payload = {"run": run} if run else {}
            rendered = client.template.render(template, payload, is_pod=True)
            print("rendered")
            print(rendered)
            spec_from_file = rendered.spec
        except Exception as e:
            console.print(f"[red]Failed to render pod template[/]: {e}")
            sys.exit(1)
    elif file:
        try:
            with open(file, "r") as f:
                spec_from_file = (
                    types.deployment.LeptonDeploymentUserSpec.model_validate_json(
                        f.read()
                    )
                )
        except Exception as e:
            console.print(f"Cannot load pod spec from file [red]{file}[/]: {e}")
            sys.exit(1)

    deployment_user_spec = spec_from_file or types.deployment.LeptonDeploymentUserSpec()

    if container_image or container_command:
        if container_image is None and not file:
            console.print(
                "Error: container image and command must be specified together."
            )
            sys.exit(1)

        if deployment_user_spec.container is None:
            deployment_user_spec.container = LeptonContainer(
                image=container_image,
                command=(
                    ["/bin/bash", "-c", container_command]
                    if container_command
                    else None
                ),
            )
        else:
            if container_image:
                deployment_user_spec.container.image = container_image
            if container_command:
                deployment_user_spec.container.command = [
                    "/bin/bash",
                    "-c",
                    container_command,
                ]

    if resource_shape:
        if deployment_user_spec.resource_requirement is None:
            deployment_user_spec.resource_requirement = ResourceRequirement(
                resource_shape=resource_shape or DEFAULT_RESOURCE_SHAPE,
            )
        else:
            deployment_user_spec.resource_requirement.resource_shape = resource_shape
    elif not deployment_user_spec.resource_requirement.resource_shape:
        available_types = "\n      ".join(VALID_SHAPES)
        console.print(
            "[red]Error: Missing option '--resource-shape'.[/] "
            f"Available types are:\n      {available_types} \n"
        )
        sys.exit(1)
    # Apply shared node group / queue / reservation config
    try:
        apply_nodegroup_and_queue_config(
            spec=deployment_user_spec,
            node_groups=node_groups,
            node_ids=node_ids,
            queue_priority=queue_priority,
            can_be_preempted=can_be_preempted,
            can_preempt=can_preempt,
            with_reservation=with_reservation,
            allow_burst=allow_burst_to_other_reservation,
        )
    except ValueError as e:
        console.print(f"[red]{e}[/]")
        sys.exit(1)

    # Configure container ports first (ensure container exists)
    if container_port:
        try:
            parsed_ports = make_container_ports_from_str_list(list(container_port))
        except ValueError as e:
            console.print(f"[red]Error[/]: {e}")
            sys.exit(1)

        if deployment_user_spec.container is None:
            deployment_user_spec.container = LeptonContainer()
        deployment_user_spec.container.ports = parsed_ports

        # Summarize configured strategies for user confirmation
        strategies_set = {
            s.value for cp in parsed_ports for s in (cp.expose_strategies or [])
        }
        ports_msg = ", ".join(
            f"{cp.container_port}/{cp.protocol}" for cp in parsed_ports
        )
        console.print(
            f"Configured container ports: [cyan]{ports_msg}[/] with strategies"
            f" [cyan]{', '.join(sorted(strategies_set))}[/]"
        )
        console.print(
            "[yellow]Notice:[/] Exposing container ports may increase your service's"
            " security risk. Please implement appropriate authentication and security"
            " controls; you are solely responsible for the security of any services"
            " exposed."
        )

    if mount:
        deployment_user_spec.mounts = make_mounts_from_strings(mount)

    if image_pull_secrets:
        deployment_user_spec.image_pull_secrets = image_pull_secrets

    if env or secret:
        deployment_user_spec.envs = make_env_vars_from_strings(list(env), list(secret))

    deployment_user_spec.is_pod = True

    if log_collection is not None:
        deployment_user_spec.log = LeptonLog(enable_collection=log_collection)
    if privileged:
        if getattr(deployment_user_spec, "user_security_context", None) is None:
            deployment_user_spec.user_security_context = LeptonUserSecurityContext(
                privileged=True
            )
        else:
            deployment_user_spec.user_security_context.privileged = True

    try:
        deployment_spec = types.deployment.LeptonDeployment(
            metadata=types.common.Metadata(name=name),
            spec=deployment_user_spec,
        )

    except ValueError as e:
        console.print(f"Error encountered while processing pod configs:\n[red]{e}[/].")
        console.print("Failed to create pod.")
        sys.exit(1)

    logger.trace(json.dumps(deployment_spec.model_dump(), indent=2))
    client.photon.run(deployment_spec)

    console.print(f"Pod launched as [green]{name}[/]")


@pod.command()
@click.option("--name", "-n", help="Pod name", required=True, type=str)
@click.option(
    "--path",
    "-p",
    type=click.Path(
        exists=False,
        file_okay=True,
        dir_okay=True,
        writable=True,
        readable=True,
        resolve_path=True,
    ),
    help=(
        "Optional local path to save the pod spec JSON. Directory or full filename"
        " accepted.\nIf a directory is provided, the file will be saved as"
        " pod-spec-<name>.json."
    ),
    required=False,
)
def get(name, path):
    """Show pod detail and optionally save its spec JSON."""

    client = APIClient()

    dep = client.deployment.get(name)
    if not dep.spec.is_pod:
        console.print(f"[red]{name} is not a pod.[/]")
        sys.exit(1)

    console.print(json.dumps(client.deployment.safe_json(dep), indent=2))

    if path:
        import os

        spec_json = dep.spec.model_dump_json(indent=2)
        save_path = path
        if os.path.isdir(path) or path.endswith(os.sep):
            os.makedirs(path, exist_ok=True)
            save_path = os.path.join(path, f"pod-spec-{name}.json")
        else:
            parent = os.path.dirname(save_path)
            if parent:
                os.makedirs(parent, exist_ok=True)

        try:
            with open(save_path, "w") as f:
                f.write(spec_json)
            console.print(f"Pod spec saved to [green]{save_path}[/].")
        except Exception as e:
            console.print(f"[red]Failed to save spec: {e}[/]")
            sys.exit(1)


@pod.command(name="list")
@click.option(
    "--pattern",
    "-p",
    help="Regular expression pattern to filter pod names.",
    default=None,
)
@click.option(
    "--detail",
    "-d",
    is_flag=True,
    default=False,
    help="Show SSH/TCP/JupyterLab columns in the table.",
)
def list_command(pattern, detail):
    """
    Lists all pods in the current workspace.
    """
    client = APIClient()

    deployments = client.deployment.list_all()

    logger.trace(f"Deployments:\n{[d for d in deployments if d.spec.is_pod]}")
    pods = [
        d
        for d in deployments
        if d.spec.is_pod and (pattern is None or re.search(pattern, d.metadata.name))
    ]
    if len(pods) == 0:
        console.print("No pods found. Use `lep pod create` to create pods.")
        return 0

    pods_count = len(pods)
    ssh_ports = [None] * pods_count
    tcp_ports = [None] * pods_count
    tcp_ports_jupyterlab = [None] * pods_count
    for index, pod in enumerate(pods):
        ports = pod.status.container_port_status if pod.status else None
        if not ports:
            continue

        port_pairs = [(p.container_port, p.host_port) for p in ports]

        for port_pair in port_pairs:
            if port_pair[0] == SSH_PORT:
                ssh_ports[index] = port_pair
            elif port_pair[0] == TCP_PORT:
                tcp_ports[index] = port_pair
            elif port_pair[0] == TCP_JUPYTER_PORT:
                tcp_ports_jupyterlab[index] = port_pair

    pod_ips = [None] * pods_count
    for index, pod in enumerate(pods):
        if pod.status.state in ("Running", "Ready"):
            public_ip = _get_only_replica_public_ip(pod.metadata.name)
            pod_ips[index] = public_ip
    logger.trace(f"Pod IPs:\n{pod_ips}")

    # Build table with Node Group column and Shape moved to the last
    if not detail:
        headers = [
            "Name / ID",
            "Node Group ID",
            "State",
            "User ID",
            "Created At",
            "Shape",
        ]
    else:
        headers = [
            "Name / ID",
            "Node Group ID",
            "State",
            "User ID",
            "SSH Command",
            "TCP Port Mapping",
            "TCP Port Mapping (JupyterLab)",
            "Created At",
            "Shape",
        ]

    dashboard_base_url = client.get_dashboard_base_url()
    rows = []
    shape_totals = {}
    for pod, ssh_port, tcp_port, tcp_port_jupyterlab, pod_ip in zip(
        pods, ssh_ports, tcp_ports, tcp_ports_jupyterlab, pod_ips
    ):
        # Pod URLs use name, per existing ssh fallback hints
        pod_url = (
            f"{dashboard_base_url}/compute/pods/detail/{pod.metadata.name}/connect"
            if dashboard_base_url
            else None
        )
        name_cell = make_name_id_cell(
            pod.metadata.name,
            getattr(pod.metadata, "id_", ""),
            link=pod_url,
            link_target="name",
        )

        state_raw = getattr(pod.status, "state", None)
        state_cell = colorize_state(state_raw)

        if detail:
            ssh_cmd = (
                f"ssh -p {ssh_port[1]} root@{pod_ip}"
                if (pod_ip and ssh_port)
                else "Not Available"
            )
            tcp_map = (
                f"{tcp_port[0]} -> {tcp_port[1]} \n(pod  -> client)"
                if tcp_port
                else "Not Available"
            )
            jupyter_map = (
                f"{tcp_port_jupyterlab[0]} -> {tcp_port_jupyterlab[1]} \n(pod  ->"
                " client)"
                if tcp_port_jupyterlab
                else "Not Available"
            )

        created_at = format_timestamp_ms(getattr(pod.metadata, "created_at", None))

        # Node Group(s)
        ng_list = []
        rr = pod.spec.resource_requirement if pod.spec else None
        if (
            rr
            and getattr(rr, "affinity", None)
            and rr.affinity.allowed_dedicated_node_groups
        ):
            ng_list = rr.affinity.allowed_dedicated_node_groups
        ng_str = "\n".join(ng_list).lower() if ng_list else ""

        # Shape
        shape = rr.resource_shape if rr and rr.resource_shape else "-"

        # Owner
        owner = getattr(pod.metadata, "owner", "") or ""

        if not detail:
            row = [
                name_cell,
                ng_str,
                state_cell,
                owner,
                created_at,
                shape,
            ]
        else:
            row = [
                name_cell,
                ng_str,
                state_cell,
                owner,
                ssh_cmd,
                tcp_map,
                jupyter_map,
                created_at,
                shape,
            ]
        rows.append(row)

    # Print table
    table = Table(title="pods", show_lines=True, show_header=True)
    for h in headers:
        table.add_column(h)
    for row in rows:
        table.add_row(*row)
    console.print(table)

    # Resource Utilization Summary for pods: count pods per shape in active states
    active_states = {"Ready", "Running", "Starting", "Updating", "Scaling", "Deleting"}
    for pod in pods:
        rr = pod.spec.resource_requirement if pod.spec else None
        shape = rr.resource_shape if rr and rr.resource_shape else "-"
        state_val = getattr(
            getattr(pod.status, "state", None),
            "value",
            getattr(pod.status, "state", None),
        )
        if state_val in active_states:
            shape_totals[shape] = shape_totals.get(shape, 0) + 1

    console.print(
        f"[bold]Resource Utilization Summary for above [cyan]{len(pods)}[/] pods (Ready"
        " / Running / Starting / Updating / Scaling / Deleting only):[/]"
    )
    for shape, total in sorted(
        shape_totals.items(), key=lambda kv: kv[1], reverse=True
    ):
        console.print(f"  [bright_black]{shape}[/] : [bold cyan]{total}[/]")
    console.print("\n")
    if detail:
        console.print(
            "* TCP port mapping(JupyterLab) defaults to the port that JupyterLab"
            " listens on."
        )
    else:
        console.print(
            "* use `lep pod list --detail` to show SSH/TCP/JupyterLab columns."
        )
    return 0


@pod.command()
@click.option("--name", "-n", help="The pod name to remove.", required=True)
def remove(name):
    """
    Removes a pod.
    """

    client = APIClient()

    client.deployment.delete(name)
    console.log(f"Pod [green]{name}[/] removed.")

    return 0


@pod.command()
@click.option("--name", "-n", help="The pod name to ssh.", required=True)
def ssh(name):
    """SSH into a running pod."""
    client = APIClient()

    pod = client.deployment.get(name)
    logger.trace(json.dumps(pod.model_dump(), indent=2))
    ports = pod.status.container_port_status
    if pod.status.state not in ("Running", "Ready"):
        console.print("This pod is not running or is not ready.")
        sys.exit(1)

    notice_msg = (
        "[yellow]Notice[/]: lep pod output may only work for default image and default"
        " command"
    )

    public_ip = _get_only_replica_public_ip(pod.metadata.name)

    if not public_ip:
        dashboard_base_url = client.get_dashboard_base_url()
        console.print(
            "No public IP is found, you can choose to use the web terminal to access"
            " the pod."
            + (
                f"\n{dashboard_base_url}/compute/pods/detail/{name}/terminal \n"
                if dashboard_base_url
                else ""
            )
        )
        sys.exit(0)

    ssh_flag = False
    for port in ports:
        if port.container_port == SSH_PORT:
            ssh_flag = True
            try:
                logger.trace(f"ssh -p {port.host_port} root@{public_ip}")
                subprocess.run(
                    ["ssh", "-p", str(port.host_port), f"root@{str(public_ip)}"],
                    check=True,
                    stderr=subprocess.PIPE,
                )
            except subprocess.CalledProcessError as e:
                if e.returncode == 130:
                    console.print("[green] SSH session exited normally.[/]")
                else:
                    console.print(
                        f"[red]SSH command failed with exit statu[/] {e.returncode}"
                    )
                    console.print(notice_msg)
                    console.print(
                        "[red]Error output:"
                        f" {e.stderr if e.stderr else 'No error output captured.'}[/]"
                    )
                    console.print(notice_msg)
            except Exception as e:
                console.print(f"[red]An unexpected error occurred: {str(e)}[/]")
                console.print(notice_msg)

    if not ssh_flag:
        dashboard_base_url = client.get_dashboard_base_url()
        console.print(
            "SSH port not found, you can choose to use the web terminal to access the"
            " pod."
            + (
                f"\n{dashboard_base_url}/compute/pods/detail/{name}/terminal \n"
                if dashboard_base_url
                else ""
            )
        )
        console.print(notice_msg)
        sys.exit(1)


@pod.command()
@click.option("--name", "-n", help="The endpoint name to stop.", required=True)
def stop(name):
    """
    Stops a pod by its name.
    """
    client = APIClient()
    endpoint = client.deployment.get(name)
    if endpoint.status.state in [
        LeptonDeploymentState.Stopped,
        LeptonDeploymentState.Stopping,
        LeptonDeploymentState.Deleting,
        LeptonDeploymentState.NotReady,
    ]:
        console.print(
            f"[yellow]⚠ Pod [green]{name}[/] is {endpoint.status.state}. No"
            " action taken.[/]"
        )
        sys.exit(0)
    client.deployment.stop(name)
    console.print(f"Pod [green]{name}[/] stopped successfully.")


def add_command(cli_group):
    cli_group.add_command(pod)
