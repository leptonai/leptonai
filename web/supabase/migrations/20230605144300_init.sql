
-- this table will be used to store the cluster information
create table public.clusters
(
    "id"            uuid   not null primary key default gen_random_uuid(),
    "created_at"    timestamp with time zone default now(),
    "token" text   not null unique,
    "url"   text   not null
);

-- this table will be used to store the user information
create table public.users
(
    "id"         uuid    not null primary key default gen_random_uuid(),
    "created_at" timestamp with time zone     default now(),
    "auth_user_id"    uuid references auth.users ("id"),
    "email"      text    not null unique,
    "enable"     boolean not null             default true
);

-- this table will be used to store the user and cluster relationship
create table public.user_cluster
(
    "id"         bigint not null primary key generated by default as identity,
    "cluster_id" uuid   not null references public.clusters ("id") on delete cascade,
    "user_id"    uuid   not null references public.users ("id") on delete cascade
);


alter table public.clusters enable row level security;
alter table public.user_cluster enable row level security;
alter table public.users enable row level security;

-- create a policy to allow users to read their own data
create
policy "enable read access for users based on email"
on public.users for
select
    using (lower(auth.jwt() ->> 'email') = lower(email));

-- create a policy to allow users to read their own data
create
policy "enable read access for authenticated users"
on public.user_cluster for
select
    using (auth.uid() in (select auth_user_id from public.users where (users.id = user_cluster.user_id)));


-- create a policy to allow users to read their own data
create
policy "enable read access for assigned users"
on public.clusters for
select
    using (clusters.id in (select user_cluster.cluster_id from public.user_cluster where (user_cluster.user_id = (select id from public.users where (auth.uid() = users.auth_user_id)))));

-- create a function to handle new users
create function public.handle_new_user()
    returns trigger
    language plpgsql
    security definer set search_path = public
as $$
begin
    if exists(select 1 from public.users where email = lower(new.email)) then
        update public.users set auth_user_id = new.id where email = lower(new.email);
    end if;
    return new;
end;
$$;

-- trigger the function every time a user is created
create trigger on_auth_user_created
    after insert on auth.users
    for each row execute procedure public.handle_new_user();
