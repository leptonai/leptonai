-- noinspection SqlNoDataSourceInspectionForFile

-- this table will be used to store the workspace information
create table public.workspaces
(
  "id"              text unique not null primary key,
  "created_at"      timestamp with time zone default now(),
  "consumer_id"     text,
  "subscription_id" text
);

-- this table will be used to store the user information
create table public.users
(
  "id"           uuid    not null primary key default gen_random_uuid(),
  "created_at"   timestamp with time zone     default now(),
  "auth_user_id" uuid references auth.users ("id"),
  "email"        text    not null unique,
  "enable"       boolean not null             default true,
  "company"      text,
  "company_size" text,
  "industry"     text,
  "name"         text,
  "role"         text,
  "work_email"   text
);

-- this table will be used to store the user and workspace relationship and the token
create table public.user_workspace
(
  "id"           bigint not null primary key generated by default as identity,
  "workspace_id" text   not null references public.workspaces ("id") on delete cascade,
  "user_id"      uuid   not null references public.users ("id") on delete cascade,
  "token"        text   not null
);


alter table public.workspaces enable row level security;
alter table public.user_workspace enable row level security;
alter table public.users enable row level security;

-- create a policy to allow users to read their own data
create
policy "enable read access for users based on email"
on public.users for
select
    using (lower(auth.jwt() ->> 'email') = lower(email));

-- create a policy to allow users to read their own data
create
policy "enable read access for authenticated users"
on public.user_workspace for
select
    using (auth.uid() in (select auth_user_id from public.users where (users.id = user_workspace.user_id)));


-- create a policy to allow users to read their own data
create
policy "enable read access for assigned users"
on public.workspaces for
select
    using (workspaces.id in (select user_workspace.workspace_id from public.user_workspace where (user_workspace.user_id = (select id from public.users where (auth.uid() = users.auth_user_id)))));

-- create a function to handle new users
CREATE OR REPLACE FUNCTION public.handle_new_user()
  RETURNS trigger
  LANGUAGE plpgsql
  SECURITY DEFINER
  SET search_path TO 'public'
AS $function$begin
  if exists(select 1 from public.users where email = lower(new.email)) then
    update public.users set auth_user_id = new.id where email = lower(new.email);
  else
    insert into public.users (email, auth_user_id, enable) values (lower(new.email), new.id, false);
  end if;
  return new;
end;$function$
;

-- trigger the function every time a user is created
create trigger on_auth_user_created
    after insert on auth.users
    for each row execute procedure public.handle_new_user();

-- create a function to handle join waitlist
CREATE OR REPLACE FUNCTION public.join_waitlist(company text, company_size text, industry text, role text, name text, work_email text)
  RETURNS void
  LANGUAGE plpgsql
  SECURITY DEFINER
  SET search_path TO 'public'
AS $function$begin
  update users set company = join_waitlist.company, role = join_waitlist.role, industry = join_waitlist.industry, company_size = join_waitlist.company_size, name = join_waitlist.name, work_email = join_waitlist.work_email where users.auth_user_id = auth.uid();
end;$function$
;
